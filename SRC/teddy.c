/************/
/* INCLUDES */
/************/
//std
#include "stdarg.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

//glfw
#define GLFW_INCLUDE_GLEXT
#include "GLFW/glfw3.h"

//teddy
#include "teddy.h"

/***********/
/* DEFINES */
/***********/
#define UNUSED(x) (void)(x)

#define TEDDY_VERSION           "TEDDY 1.0"//LOL

//opengl
#define T_OPENGL_MAJOR          4
#define T_OPENGL_MINOR          5
#define T_FGCOLOR               "FgColor"
#define T_BGCOLOR               "BgColor"

//glyphs
#define T_DEFAULT_GLYPH_W       8
#define T_DEFAULT_GLYPH_H       8

/************/
/* TYPEDEFS */
/************/
typedef struct Teddy
{
    int rows;
    int cols;

    int cursor;

    char *prompt;
    char *prompt_header;
    int prompt_pos;
    int prompt_typing;
    int prompt_ready;
    
    int texture_w;
    int texture_h;
    unsigned char *texture_buffer;

    int glyph_w;
    int glyph_h;
    unsigned char **glyphs;
    
    //glfw
    GLFWwindow *window;

    //opengl
    GLuint vao;
    GLuint vbo;
    GLuint vert_shader;
    GLuint frag_shader;
    GLuint prog_shader;
    GLuint texture;

} Teddy;

/**********/
/* STATIC */
/**********/
static Teddy *teddy = NULL;

static const unsigned char T_DEFAULT_FONT[2048] = 
{
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E, 
0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E, 0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00, 
0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x38, 0x7C, 0x38, 0xFE, 0xFE, 0xD6, 0x10, 0x38,
0x10, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x10, 0x38, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00, 
0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF, 0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00, 
0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF, 0x0F, 0x07, 0x0F, 0x7D, 0xCC, 0xCC, 0xCC, 0x78,
0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, 0x3F, 0x33, 0x3F, 0x30, 0x30, 0x70, 0xF0, 0xE0, 
0x7F, 0x63, 0x7F, 0x63, 0x63, 0x67, 0xE6, 0xC0, 0x18, 0xDB, 0x3C, 0xE7, 0xE7, 0x3C, 0xDB, 0x18, 
0x80, 0xE0, 0xF8, 0xFE, 0xF8, 0xE0, 0x80, 0x00, 0x02, 0x0E, 0x3E, 0xFE, 0x3E, 0x0E, 0x02, 0x00,
0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
0x7F, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x00, 0x3E, 0x63, 0x38, 0x6C, 0x6C, 0x38, 0xCC, 0x78, 
0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF,
0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00, 
0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00, 
0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00, 0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00,
0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00, 
0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,
0x30, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x30, 0x00, 0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00, 
0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00, 0x60, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00, 0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00,
0x7C, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6, 0x7C, 0x00, 0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00, 
0x78, 0xCC, 0x0C, 0x38, 0x60, 0xCC, 0xFC, 0x00, 0x78, 0xCC, 0x0C, 0x38, 0x0C, 0xCC, 0x78, 0x00, 
0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00, 0xFC, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00,
0x38, 0x60, 0xC0, 0xF8, 0xCC, 0xCC, 0x78, 0x00, 0xFC, 0xCC, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00, 
0x78, 0xCC, 0xCC, 0x78, 0xCC, 0xCC, 0x78, 0x00, 0x78, 0xCC, 0xCC, 0x7C, 0x0C, 0x18, 0x70, 0x00, 
0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
0x18, 0x30, 0x60, 0xC0, 0x60, 0x30, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0xFC, 0x00, 0x00, 
0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x78, 0xCC, 0x0C, 0x18, 0x30, 0x00, 0x30, 0x00, 
0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00, 0x30, 0x78, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0x00,
0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00, 0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00, 
0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00, 
0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00, 0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3E, 0x00,
0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 
0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00, 0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00, 
0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00,
0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 
0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0xDC, 0x78, 0x1C, 0x00, 
0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00, 0x78, 0xCC, 0x60, 0x30, 0x18, 0xCC, 0x78, 0x00,
0xFC, 0xB4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFC, 0x00, 
0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00, 0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00, 
0xC6, 0xC6, 0x6C, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x30, 0x78, 0x00,
0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00, 0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00, 
0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00, 
0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00, 
0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0xDC, 0x00, 0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00, 
0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
0x38, 0x6C, 0x60, 0xF0, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, 
0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00, 0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00, 
0x0C, 0x00, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00,
0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xC6, 0x00, 
0x00, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, 0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 
0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E,
0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x00, 
0x10, 0x30, 0x7C, 0x30, 0x30, 0x34, 0x18, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 
0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00, 0x00, 0x00, 0xC6, 0xD6, 0xFE, 0xFE, 0x6C, 0x00,
0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, 
0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00, 0x1C, 0x30, 0x30, 0xE0, 0x30, 0x30, 0x1C, 0x00, 
0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00, 0xE0, 0x30, 0x30, 0x1C, 0x30, 0x30, 0xE0, 0x00,
0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00, 
0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x18, 0x0C, 0x78, 0x00, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00, 
0x1C, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00, 0x7E, 0xC3, 0x3C, 0x06, 0x3E, 0x66, 0x3F, 0x00,
0xCC, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00, 0xE0, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00, 
0x30, 0x30, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00, 0x00, 0x00, 0x78, 0xC0, 0xC0, 0x78, 0x0C, 0x38, 
0x7E, 0xC3, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00, 0xCC, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
0xE0, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00, 0xCC, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00, 
0x7C, 0xC6, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00, 0xE0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00, 
0xC6, 0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0x00, 0x30, 0x30, 0x00, 0x78, 0xCC, 0xFC, 0xCC, 0x00,
0x1C, 0x00, 0xFC, 0x60, 0x78, 0x60, 0xFC, 0x00, 0x00, 0x00, 0x7F, 0x0C, 0x7F, 0xCC, 0x7F, 0x00, 
0x3E, 0x6C, 0xCC, 0xFE, 0xCC, 0xCC, 0xCE, 0x00, 0x78, 0xCC, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00,
0x00, 0xCC, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0xE0, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 
0x78, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00, 0x00, 0xE0, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00, 
0x00, 0xCC, 0x00, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, 0xC3, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x00, 
0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x18, 0x18, 0x7E, 0xC0, 0xC0, 0x7E, 0x18, 0x18,
0x38, 0x6C, 0x64, 0xF0, 0x60, 0xE6, 0xFC, 0x00, 0xCC, 0xCC, 0x78, 0xFC, 0x30, 0xFC, 0x30, 0x30, 
0xF8, 0xCC, 0xCC, 0xFA, 0xC6, 0xCF, 0xC6, 0xC7, 0x0E, 0x1B, 0x18, 0x3C, 0x18, 0x18, 0xD8, 0x70, 
0x1C, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00, 0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
0x00, 0x1C, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x1C, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00, 
0x00, 0xF8, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0x00, 0xFC, 0x00, 0xCC, 0xEC, 0xFC, 0xDC, 0xCC, 0x00, 
0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7C, 0x00, 0x00,
0x30, 0x00, 0x30, 0x60, 0xC0, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xC0, 0xC0, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xFC, 0x0C, 0x0C, 0x00, 0x00, 0xC3, 0xC6, 0xCC, 0xDE, 0x33, 0x66, 0xCC, 0x0F, 
0xC3, 0xC6, 0xCC, 0xDB, 0x37, 0x6F, 0xCF, 0x03, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00,
0x00, 0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00, 0x00, 0xCC, 0x66, 0x33, 0x66, 0xCC, 0x00, 0x00, 
0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 
0xDB, 0x77, 0xDB, 0xEE, 0xDB, 0x77, 0xDB, 0xEE, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18, 
0x36, 0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x36, 0x36, 0x36, 
0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x36, 0x36, 0xF6, 0x06, 0xF6, 0x36, 0x36, 0x36,
0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0xFE, 0x06, 0xF6, 0x36, 0x36, 0x36, 
0x36, 0x36, 0xF6, 0x06, 0xFE, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0xFE, 0x00, 0x00, 0x00, 
0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18,
0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18, 
0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18,
0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36, 
0x36, 0x36, 0x37, 0x30, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x30, 0x37, 0x36, 0x36, 0x36, 
0x36, 0x36, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x36, 0x36, 0x36,
0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 
0x36, 0x36, 0xF7, 0x00, 0xF7, 0x36, 0x36, 0x36, 0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 
0x36, 0x36, 0x36, 0x36, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18,
0x00, 0x00, 0x00, 0x00, 0xFF, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3F, 0x00, 0x00, 0x00, 
0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 
0x00, 0x00, 0x00, 0x00, 0x3F, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, 0x36, 0x36, 0x36,
0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x76, 0xDC, 0xC8, 0xDC, 0x76, 0x00, 0x00, 0x78, 0xCC, 0xF8, 0xCC, 0xF8, 0xC0, 0xC0, 
0x00, 0xFC, 0xCC, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0xFE, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00,
0xFC, 0xCC, 0x60, 0x30, 0x60, 0xCC, 0xFC, 0x00, 0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0x70, 0x00, 
0x00, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0xC0, 0x00, 0x76, 0xDC, 0x18, 0x18, 0x18, 0x18, 0x00, 
0xFC, 0x30, 0x78, 0xCC, 0xCC, 0x78, 0x30, 0xFC, 0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0x6C, 0x38, 0x00,
0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x6C, 0xEE, 0x00, 0x1C, 0x30, 0x18, 0x7C, 0xCC, 0xCC, 0x78, 0x00, 
0x00, 0x00, 0x7E, 0xDB, 0xDB, 0x7E, 0x00, 0x00, 0x06, 0x0C, 0x7E, 0xDB, 0xDB, 0x7E, 0x60, 0xC0, 
0x38, 0x60, 0xC0, 0xF8, 0xC0, 0x60, 0x38, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x00,
0x00, 0xFC, 0x00, 0xFC, 0x00, 0xFC, 0x00, 0x00, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x00, 0xFC, 0x00, 
0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xFC, 0x00, 0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xFC, 0x00, 
0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0xD8, 0x70,
0x30, 0x30, 0x00, 0xFC, 0x00, 0x30, 0x30, 0x00, 0x00, 0x76, 0xDC, 0x00, 0x76, 0xDC, 0x00, 0x00, 
0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x0F, 0x0C, 0x0C, 0x0C, 0xEC, 0x6C, 0x3C, 0x1C,
0x78, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x70, 0x18, 0x30, 0x60, 0x78, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const float T_TEXTURE_VERTICES[16] = 
{
-1.0f, -1.0f, 0.0f, 1.0f,
-1.0f,  1.0f, 0.0f, 0.0f,
 1.0f, -1.0f, 1.0f, 1.0f,
 1.0f,  1.0f, 1.0f, 0.0f
};

static const char T_VERT_SRC[] = "\
#version 450\n\
layout (location = 0) in vec2 Pos;\n\
layout (location = 1) in vec2 Uv;\n\
out vec2 Tex;\n \
void main()\n\
{\n\
    gl_Position = vec4(Pos, 0.0f, 1.0f);\n\
    Tex = Uv;\n\
}\n";

static const char T_FRAG_SRC[] = "\
#version 450\n\
in vec2 Tex;\n\
uniform sampler2D Texture;\n\
uniform vec3 FgColor;\n\
uniform vec3 BgColor;\n\
out vec4 final;\n\
void main()\n\
{\n\
    float val = texture(Texture, Tex).r;\n\
    final = vec4(val*FgColor, 1.0f);\n\
    if( final==vec4(0.0f,0.0f,0.0f,1.0f) ) { final=vec4(BgColor,1.0f); }\n\
}\n";

//log
static PFNGLGETPROGRAMINFOLOGPROC glGetProgramInfoLog = NULL;
static PFNGLDEBUGMESSAGECALLBACKPROC glDebugMessageCallback = NULL;

//program
static PFNGLCREATEPROGRAMPROC glCreateProgram = NULL;
static PFNGLDELETEPROGRAMPROC glDeleteProgram = NULL;
static PFNGLUSEPROGRAMPROC glUseProgram = NULL;
static PFNGLATTACHSHADERPROC glAttachShader = NULL;
static PFNGLDETACHSHADERPROC glDetachShader = NULL;
static PFNGLLINKPROGRAMPROC glLinkProgram = NULL;
static PFNGLGETPROGRAMIVPROC glGetProgramiv = NULL;
static PFNGLGETSHADERINFOLOGPROC glGetShaderInfoLog = NULL;
static PFNGLGETUNIFORMLOCATIONPROC glGetUniformLocation = NULL;
static PFNGLUNIFORM3FPROC glUniform3f = NULL;
static PFNGLENABLEVERTEXATTRIBARRAYPROC glEnableVertexAttribArray = NULL;
static PFNGLDISABLEVERTEXATTRIBARRAYPROC glDisableVertexAttribArray = NULL;
 
//shader
static PFNGLCREATESHADERPROC glCreateShader = NULL;
static PFNGLDELETESHADERPROC glDeleteShader = NULL;
static PFNGLSHADERSOURCEPROC glShaderSource = NULL;
static PFNGLCOMPILESHADERPROC glCompileShader = NULL;
static PFNGLGETSHADERIVPROC glGetShaderiv = NULL;
 
//VBO
static PFNGLGENBUFFERSPROC glGenBuffers = NULL;
static PFNGLBINDBUFFERPROC glBindBuffer = NULL;
static PFNGLBUFFERDATAPROC glBufferData = NULL;
static PFNGLVERTEXATTRIBPOINTERPROC glVertexAttribPointer = NULL;
static PFNGLDELETEBUFFERSPROC glDeleteBuffers = NULL;
static PFNGLBUFFERSUBDATAPROC glBufferSubData = NULL;
 
//VAO
static PFNGLGENVERTEXARRAYSPROC glGenVertexArrays = NULL;
static PFNGLBINDVERTEXARRAYPROC glBindVertexArray = NULL;
static PFNGLDELETEVERTEXARRAYSPROC glDeleteVertexArrays = NULL;

/*********************/
/* STATIC PROTOTYPES */
/*********************/
//glfw
static void TeddyGlfwResizeCallback(GLFWwindow *window, int width, int height);
static void TeddyGlfwKeyCallback(GLFWwindow *window,  int key, int scancode, int action, int mods);
static void TeddyGlfwCharCallback(GLFWwindow *window, unsigned int codepoint);
static void TeddyGlfwInit();
static void TeddyGlfwClose();

//opengl
static void TeddyOpenglLoadExtensions();
static GLuint TeddyOpenglShader(GLenum type, const char *src);
static GLuint TeddyOpenglProgramShader(GLuint vert_shader, GLuint frag_shader);
static void TeddyOpenglInit();
static void TeddyOpenglClose();

//teddy internal
static void TeddyError(char *str, ...);
static void TeddyLoadBuffer(char *file, unsigned char **buffer, int *size);
static void TeddyInitGlyphs(const unsigned char *font);
static void TeddyDrawChar(char c, int row, int col);
static void TeddyAddSubLine(char *str);
static void TeddyUpdatePrompt();
static void TeddyRender();

/********/
/* GLFW */
/********/
static void TeddyGlfwResizeCallback(GLFWwindow *window, int width, int height)
{
    UNUSED(window);

    int x = 0;
	int y = 0;
    float view_w = 0;
    float view_h = 0;

	float ratio = (float)teddy->texture_w/(float)teddy->texture_h;

	if( width/ratio < height)
	{
		view_w = width;
		view_h = (int)(view_w/ratio);
	}
	else
	{
		view_h = height;
		view_w = (int)(view_h*ratio);
	}

	x = (width - view_w)/2;
	y = (height - view_h)/2;
		
    glViewport(x, y, view_w, view_h);	

    TeddyRender();

}

/**********/
static void TeddyGlfwKeyCallback(GLFWwindow *window,  int key, int scancode, int action, int mods)
{
    UNUSED(window);
    UNUSED(scancode);
    UNUSED(mods);

    if(action==GLFW_RELEASE) { return; }
    
    switch (key)
    {
        case GLFW_KEY_BACKSPACE:
            if(teddy->prompt_pos>0) 
            { 
                teddy->prompt_pos--;
                teddy->prompt[teddy->prompt_pos] = 0;
                TeddyUpdatePrompt();
                TeddyRender();
            }      
            break;
        
        case GLFW_KEY_ENTER:
            if(teddy->prompt_typing) { teddy->prompt_ready = 1; }
            break;

        case GLFW_KEY_ESCAPE:
            glfwSetWindowShouldClose(teddy->window,1);
            break;

        default:
            break;
    }
    
}

/**********/
static void TeddyGlfwCharCallback(GLFWwindow *window, unsigned int codepoint)
{
    UNUSED(window);

    if(codepoint < 0xFF && teddy->prompt_pos<teddy->cols-1)
    {
        teddy->prompt[teddy->prompt_pos] = (char)codepoint;
        teddy->prompt_pos++;
        TeddyUpdatePrompt();
        TeddyRender();
    }
}

/**********/
static void TeddyGlfwInit()
{
    glfwInit();

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, T_OPENGL_MAJOR);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, T_OPENGL_MINOR);
    
    glfwWindowHint(GLFW_DOUBLEBUFFER, 1);
    
    teddy->window = glfwCreateWindow(teddy->texture_w, teddy->texture_h, "", NULL, NULL);

    glfwSetWindowSizeCallback(teddy->window, TeddyGlfwResizeCallback);

    glfwMakeContextCurrent(teddy->window);

    glfwSwapInterval(0);

    glfwSetKeyCallback(teddy->window, TeddyGlfwKeyCallback);
    glfwSetCharCallback(teddy->window,TeddyGlfwCharCallback);
}

/**********/
static void TeddyGlfwClose()
{
    glfwDestroyWindow(teddy->window);
 
    glfwTerminate();
}

/**********/
/* OPENGL */
/**********/
static void TeddyOpenglLoadExtensions()
{
    //log
    glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC)glfwGetProcAddress("glGetProgramInfoLog");
    glDebugMessageCallback = (PFNGLDEBUGMESSAGECALLBACKPROC)glfwGetProcAddress("glDebugMessageCallback");

    //program
    glCreateProgram = (PFNGLCREATEPROGRAMPROC)glfwGetProcAddress("glCreateProgram");
    glDeleteProgram = (PFNGLDELETEPROGRAMPROC)glfwGetProcAddress("glDeleteProgram");
    glUseProgram = (PFNGLUSEPROGRAMPROC)glfwGetProcAddress("glUseProgram");
    glAttachShader = (PFNGLATTACHSHADERPROC)glfwGetProcAddress("glAttachShader");
    glDetachShader = (PFNGLDETACHSHADERPROC)glfwGetProcAddress("glDetachShader");
    glLinkProgram = (PFNGLLINKPROGRAMPROC)glfwGetProcAddress("glLinkProgram");
    glGetProgramiv = (PFNGLGETPROGRAMIVPROC)glfwGetProcAddress("glGetProgramiv");
    glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)glfwGetProcAddress("glGetShaderInfoLog");
    glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC)glfwGetProcAddress("glGetUniformLocation");
    glUniform3f = (PFNGLUNIFORM3FPROC)glfwGetProcAddress("glUniform3f");
    glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)glfwGetProcAddress("glEnableVertexAttribArray");
    glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC)glfwGetProcAddress("glDisableVertexAttribArray");

    //shader
    glCreateShader = (PFNGLCREATESHADERPROC)glfwGetProcAddress("glCreateShader");
    glDeleteShader = (PFNGLDELETESHADERPROC)glfwGetProcAddress("glDeleteShader");
    glShaderSource = (PFNGLSHADERSOURCEPROC)glfwGetProcAddress("glShaderSource");
    glCompileShader = (PFNGLCOMPILESHADERPROC)glfwGetProcAddress("glCompileShader");
    glGetShaderiv = (PFNGLGETSHADERIVPROC)glfwGetProcAddress("glGetShaderiv");

    //VBO
    glGenBuffers = (PFNGLGENBUFFERSPROC)glfwGetProcAddress("glGenBuffers");
    glBindBuffer = (PFNGLBINDBUFFERPROC)glfwGetProcAddress("glBindBuffer");
    glBufferData = (PFNGLBUFFERDATAPROC)glfwGetProcAddress("glBufferData");
    glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC)glfwGetProcAddress("glVertexAttribPointer");
    glDeleteBuffers = (PFNGLDELETEBUFFERSPROC)glfwGetProcAddress("glDeleteBuffers");
    glBufferSubData = (PFNGLBUFFERSUBDATAPROC)glfwGetProcAddress("glBufferSubData");

    //VAO
    glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC)glfwGetProcAddress("glGenVertexArrays");
    glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC)glfwGetProcAddress("glBindVertexArray");
    glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC)glfwGetProcAddress("glDeleteVertexArrays");  
}

/**********/
static GLuint TeddyOpenglShader(GLenum type, const char *src)
{
	GLuint shader = glCreateShader(type);

	glShaderSource(shader, 1, (const GLchar**)&src, NULL);

	glCompileShader(shader);

	return shader;
}

/**********/
static GLuint TeddyOpenglProgramShader(GLuint vert_shader, GLuint frag_shader)
{
	GLuint prog_shader = glCreateProgram();

	glAttachShader(prog_shader, vert_shader);

	glAttachShader(prog_shader, frag_shader);

	glLinkProgram(prog_shader);

	return prog_shader;
}

/**********/
static void TeddyOpenglInit()
{
    TeddyOpenglLoadExtensions();

    glGenVertexArrays(1, &teddy->vao);
    glBindVertexArray(teddy->vao); 

	glGenBuffers(1, &teddy->vbo);
    glBindBuffer(GL_ARRAY_BUFFER, teddy->vbo);

	glEnableVertexAttribArray(0);//vertex 
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
	
    glEnableVertexAttribArray(1);//texture 
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)) );

	glBufferData(GL_ARRAY_BUFFER, 16*sizeof(float), T_TEXTURE_VERTICES, GL_STATIC_DRAW);	
	
	glPixelStorei(GL_UNPACK_ALIGNMENT,1);//fix for w not multiple of 4

	glGenTextures(1, &teddy->texture);

	glBindTexture(GL_TEXTURE_2D, teddy->texture);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);	
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, teddy->texture_w, teddy->texture_h, 0, GL_RED, GL_UNSIGNED_BYTE, NULL);

	teddy->vert_shader = TeddyOpenglShader(GL_VERTEX_SHADER, T_VERT_SRC);

    teddy->frag_shader = TeddyOpenglShader(GL_FRAGMENT_SHADER, T_FRAG_SRC);

    teddy->prog_shader = TeddyOpenglProgramShader(teddy->vert_shader, teddy->frag_shader);

	glUseProgram(teddy->prog_shader);

}

/**********/
static void TeddyOpenglClose()
{
    glDeleteTextures(1, &teddy->texture);

    glDisableVertexAttribArray(0);

    glDisableVertexAttribArray(1);

    glDeleteVertexArrays(1, &teddy->vao);

    glDeleteBuffers(1, &teddy->vbo);

	glDetachShader(teddy->prog_shader, teddy->vert_shader);
	glDeleteShader(teddy->vert_shader);

	glDetachShader(teddy->prog_shader, teddy->frag_shader);
	glDeleteShader(teddy->frag_shader);

	glDeleteProgram(teddy->prog_shader);
}


/****************/
/* TEDDY STATIC */
/****************/
static void TeddyError(char *str, ...)
{
	fprintf(stdout,"(*ERROR*)");

	if (str != NULL)
	{
		va_list argp;
		va_start(argp, str);
		vfprintf(stdout, str, argp);
		va_end(argp);
	};

    fprintf(stdout,"\n");

	exit(EXIT_FAILURE);
}

/**********/
static void TeddyLoadBuffer(char *file, unsigned char **buffer, int *size)
{
    FILE *fp = fopen(file, "rb");

    if(!fp){ TeddyError("unable to open file : %s",file); }

	fseek(fp, 0, SEEK_END);

	size_t _size = ftell(fp);

	*buffer = calloc( _size, sizeof(unsigned char));

    fseek(fp, 0, SEEK_SET);

	fread(*buffer, _size, 1, fp);

	fclose(fp);

	*size = (int)_size;
}

/**********/
static void TeddyInitGlyphs(const unsigned char *font)
{
    teddy->glyphs = calloc(256, sizeof(unsigned char*));

    for(int count=0;count<256;count++)
    {
        teddy->glyphs[count] = calloc(teddy->glyph_w*teddy->glyph_h, sizeof(unsigned char*));
    
        int index = teddy->glyph_h * count;

        int _count=0;

        for(int32_t i=0;i<teddy->glyph_h;i++)
        {  
            uint8_t byte = font[index];

            for(int32_t j=teddy->glyph_w-1;j>=0;j--)
            {
                teddy->glyphs[count][_count] = ((byte>>j) & 1)*0xFF;

                _count++;
            }

            index++;
        }
    }
}

/**********/
static void TeddyDrawChar(char c, int row, int col)
{
    unsigned char *p = teddy->texture_buffer;

    p += row * teddy->glyph_h * teddy->cols * teddy->glyph_w;
    p += col * teddy->glyph_w;

    unsigned char *g = teddy->glyphs[(unsigned char)c];

    for(int i=0;i<teddy->glyph_h;i++)
    {
        memcpy(p,g,teddy->glyph_w);

        p += teddy->cols * teddy->glyph_w;

        g += teddy->glyph_w;
    }
}


/**********/
static void TeddyAddSubLine(char *str)
{
    if(!str) { TeddyError("invalid string"); }

    int line_size = teddy->cols*teddy->glyph_w*teddy->glyph_h;

    unsigned char *src = teddy->texture_buffer + line_size;
    unsigned char *dst = teddy->texture_buffer;

    for(int i=0;i<teddy->rows-2;i++)
    {
        memcpy(dst,src,line_size);
        src += line_size;
        dst += line_size;
    }

    memset(dst,0x00,line_size);

    size_t limit = ( strlen(str) < (size_t)teddy->cols ) ? strlen(str) : (size_t)teddy->cols;

    for(size_t i=0;i<limit;i++)//CHECK LEN
    {
        TeddyDrawChar(str[i],teddy->rows-2,i);
    }

}

/**********/
static void TeddyUpdatePrompt()
{
    int line_size = teddy->cols*teddy->glyph_w*teddy->glyph_h;

    unsigned char *p = teddy->texture_buffer;

    p += line_size * (teddy->rows-1);

    memset(p,0x00,line_size);

    for(size_t i=0;i<strlen(teddy->prompt);i++)
    {
        TeddyDrawChar(teddy->prompt[i],teddy->rows-1,i);
    }

}

/**********/
static void TeddyRender()
{
    glClear(GL_COLOR_BUFFER_BIT);
    
    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, teddy->texture_w, teddy->texture_h, GL_RED, GL_UNSIGNED_BYTE, teddy->texture_buffer);

	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

    glfwSwapBuffers(teddy->window);
}

/****************/
/* TEDDY PUBLIC */
/****************/
void TeddyInit(int rows, int cols, char *font_file)
{
    if(rows<1 || cols<1) { TeddyError("invalid sizes"); }

    teddy = calloc(1,sizeof(Teddy));
    
    teddy->rows = rows;
    teddy->cols = cols;

    teddy->prompt = calloc(cols,sizeof(char));

    teddy->glyph_w = T_DEFAULT_GLYPH_W;
    teddy->glyph_h = T_DEFAULT_GLYPH_H;

    unsigned char *buffer = NULL;
    int buffer_size = 0;

    if(font_file)
    {
        TeddyLoadBuffer(font_file, &buffer, &buffer_size);
        teddy->glyph_h = buffer_size/256;
    }

    teddy->texture_w = teddy->cols * teddy->glyph_w;
    teddy->texture_h = teddy->rows * teddy->glyph_h;
    teddy->texture_buffer = calloc(teddy->texture_w*teddy->texture_h,sizeof(unsigned char));

    if(buffer)
    {
        TeddyInitGlyphs(buffer);
        free(buffer);
    }
    else
    {
        TeddyInitGlyphs(T_DEFAULT_FONT);
    }

    TeddyGlfwInit();    

    TeddyOpenglInit();    

    TeddyColors(0xFFFFFF,0x000000,0x000000);

    TeddyRender();
}

/**********/
void TeddyClose()
{
    TeddyOpenglClose();

    TeddyGlfwClose();

    for(int count=0;count<256;count++)
    {
        free(teddy->glyphs[count]);
    }

    free(teddy->prompt);

    free(teddy->glyphs);

    free(teddy->texture_buffer);

    free(teddy);
}

/**********/    
void TeddyColors(int fgcolor, int bgcolor, int ctxcolor)
{
    if(fgcolor>0xFFFFFF || bgcolor>0xFFFFFF || ctxcolor>0xFFFFFF) { TeddyError("invalid color format"); }

    int loc = 0;
    unsigned char r = 0;
    unsigned char g = 0;
    unsigned char b = 0;

    r = (unsigned char)(fgcolor >> 16);
    g = (unsigned char)((fgcolor >> 8) & 0xFF);
    b = (unsigned char)(fgcolor & 0xFF);
    loc = glGetUniformLocation(teddy->prog_shader, T_FGCOLOR);
    glUniform3f(loc, (float)r/0xFF, (float)g/0xFF, (float)b/0xFF );

    r = (unsigned char)(bgcolor >> 16);
    g = (unsigned char)((bgcolor >> 8) & 0xFF);
    b = (unsigned char)(bgcolor & 0xFF);
    loc = glGetUniformLocation(teddy->prog_shader, T_BGCOLOR);
    glUniform3f(loc, (float)r/0xFF, (float)g/0xFF, (float)b/0xFF );

    r = (unsigned char)(ctxcolor >> 16);
    g = (unsigned char)((ctxcolor >> 8) & 0xFF);
    b = (unsigned char)(ctxcolor & 0xFF);
    glClearColor(r/255.0f,g/255.0f,b/255.0f,1.0f);
}

/**********/
int TeddyRun()
{
    glfwPollEvents();

	return !glfwWindowShouldClose(teddy->window);
}

/**********/
void TeddyClear()
{
    int line_size = teddy->cols*teddy->glyph_w*teddy->glyph_h;

    memset(teddy->texture_buffer,0x00,(teddy->rows-1)*line_size);

    TeddyRender();
}

/**********/
void TeddyAddChar(char c)
{
    if(teddy->cursor>=teddy->cols){ return; }

    if(c=='\r' || c=='\n') 
    {
        teddy->cursor = 0;
        return;
    }

    if(teddy->cursor==0) 
    {
        int line_size = teddy->cols*teddy->glyph_w*teddy->glyph_h;

        unsigned char *src = teddy->texture_buffer + line_size;
        unsigned char *dst = teddy->texture_buffer;

        for(int i=0;i<teddy->rows-2;i++)
        {
            memcpy(dst,src,line_size);
            src += line_size;
            dst += line_size;
        }

        memset(dst,0x00,line_size);
    }
    
    TeddyDrawChar(c,teddy->rows-2,teddy->cursor);
    teddy->cursor++;

    TeddyRender();
}

/**********/
void TeddyAddLine(char *str)
{
    if(!str) { TeddyError("invalid string"); }

    int len = strlen(str);
    char *ptr = str;

    for(int i=0;i<len/teddy->cols;i++)
    {
        TeddyAddSubLine(ptr);

        ptr += teddy->cols;
    }

    if(len%teddy->cols != 0) {  TeddyAddSubLine(ptr); }

    TeddyRender();

    teddy->cursor = 0;

}

/**********/
char *TeddyReadLine()
{
    teddy->prompt_typing = 1;

    char blink = 0;

    double blink_time = glfwGetTime();

    while(1)
    {
        glfwPollEvents();

        if(glfwWindowShouldClose(teddy->window)) { break; }

        if(teddy->prompt_ready)
        {
            char *str = calloc(strlen(teddy->prompt)+1,sizeof(char));

            strcpy(str,teddy->prompt);
           
            memset(teddy->prompt,0x00,teddy->cols);

            teddy->prompt_ready=0;

            teddy->prompt_pos = 0;

            TeddyUpdatePrompt();

            TeddyRender();

            teddy->prompt_typing = 0;

            return str;
        }

        //blink
        if( glfwGetTime() - blink_time > 0.350)
        {
            blink = (blink==0) ? 0xDB : 0;

            TeddyDrawChar(blink,(teddy->rows-1),teddy->prompt_pos);
            
            TeddyRender();

            blink_time = glfwGetTime();
        }
    }

    teddy->prompt_typing = 0;

    return NULL;
}

